package com.y5neko.shiroexp.ui.tabpane;

import com.y5neko.shiroexp.config.AllList;
import com.y5neko.shiroexp.config.ExploitConfig;
import com.y5neko.shiroexp.object.TargetOBJ;
import com.y5neko.shiroexp.payloads.CommandExcute;
import com.y5neko.shiroexp.payloads.MemshellService;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;

import java.net.URL;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

/**
 * 漏洞利用标签页
 * 包含命令执行和内存马注入功能
 */
public class ExploitTab {
    // 静态引用，用于外部更新UI
    private static ExploitTab instance;

    private TextField targetUrlTextField;
    private TextField keyTextField;
    private TextField keywordTextField;  // RememberMe Keyword
    private ComboBox<String> requestTypeComboBox;  // 请求方式
    private ComboBox<String> cryptTypeComboBox;    // 加密方式
    private ComboBox<String> gadgetComboBox;
    private ComboBox<String> echoComboBox;
    private TextArea logTextArea;
    private TextField cookieTextField;
    private ComboBox<String> contentTypeComboBox;  // Content-Type 下拉框
    private TextField requestBodyTextField;        // 请求体输入框
    private String customMemshellBase64 = null;    // 存储自定义内存马字节码

    public VBox getExploitTab() {
        // 注册实例
        instance = this;
        VBox exploitTab = new VBox();
        exploitTab.setSpacing(10);
        exploitTab.setPadding(new Insets(10));
        exploitTab.getStylesheets().add("css/TextField.css");

        // =========================== 第一行：目标配置 ==========================
        HBox targetConfigBox = new HBox();
        targetConfigBox.setAlignment(Pos.CENTER);
        targetConfigBox.setSpacing(10);
        targetConfigBox.setPadding(new Insets(0, 0, 10, 0));

        Label requestTypeLabel = new Label("请求方式: ");
        ObservableList<String> requestType = FXCollections.observableArrayList("GET", "POST");
        requestTypeComboBox = new ComboBox<>(requestType);
        requestTypeComboBox.setValue("GET");

        Label targetUrlLabel = new Label("目标地址: ");
        targetUrlTextField = new TextField();
        targetUrlTextField.setPromptText("http://example.com");
        HBox.setHgrow(targetUrlTextField, javafx.scene.layout.Priority.ALWAYS);

        targetConfigBox.getChildren().addAll(requestTypeLabel, requestTypeComboBox, targetUrlLabel, targetUrlTextField);

        // =========================== 第二行：RememberMe 配置 ==========================
        HBox rememberMeConfigBox = new HBox();
        rememberMeConfigBox.setAlignment(Pos.CENTER);
        rememberMeConfigBox.setSpacing(10);
        rememberMeConfigBox.setPadding(new Insets(0, 0, 10, 0));

        Label keywordLabel = new Label("Keyword: ");
        keywordTextField = new TextField("rememberMe");
        HBox.setHgrow(keywordTextField, javafx.scene.layout.Priority.ALWAYS);

        Label keyLabel = new Label("指定rememberMe: ");
        keyTextField = new TextField();
        keyTextField.setPromptText("Shiro Key");
        HBox.setHgrow(keyTextField, javafx.scene.layout.Priority.ALWAYS);

        Label cryptTypeLabel = new Label("加密方式: ");
        ObservableList<String> cryptType = FXCollections.observableArrayList("CBC", "GCM");
        cryptTypeComboBox = new ComboBox<>(cryptType);
        cryptTypeComboBox.setValue("CBC");

        Button clearLogButton = new Button("清除日志");

        rememberMeConfigBox.getChildren().addAll(keywordLabel, keywordTextField, keyLabel, keyTextField, cryptTypeLabel, cryptTypeComboBox, clearLogButton);

        // =========================== 第三行：利用链配置 ===========================
        HBox exploitConfigBox = new HBox();
        exploitConfigBox.setAlignment(Pos.CENTER);
        exploitConfigBox.setSpacing(10);

        Label gadgetLabel = new Label("利用链: ");
        ObservableList<String> gadgets = FXCollections.observableArrayList(AllList.gadgets);
        gadgetComboBox = new ComboBox<>(gadgets);
        if (!gadgets.isEmpty()) {
            gadgetComboBox.setValue(gadgets.get(0));
        }

        Label echoLabel = new Label("回显方式: ");
        ObservableList<String> echoes = FXCollections.observableArrayList(AllList.echoGadgets);
        echoComboBox = new ComboBox<>(echoes);
        if (!echoes.isEmpty()) {
            echoComboBox.setValue(echoes.get(0));
        }

        exploitConfigBox.getChildren().addAll(gadgetLabel, gadgetComboBox, echoLabel, echoComboBox);

        // =========================== 第四行：高级配置 ===========================
        TitledPane advancedConfigPane = new TitledPane();
        advancedConfigPane.setText("高级配置");
        advancedConfigPane.setCollapsible(true);
        advancedConfigPane.setExpanded(false);

        VBox advancedConfigContent = new VBox();
        advancedConfigContent.setSpacing(10);
        advancedConfigContent.setPadding(new Insets(10, 0, 10, 0));

        // Cookie 配置
        HBox cookieBox = new HBox();
        cookieBox.setAlignment(Pos.CENTER);
        cookieBox.setSpacing(10);

        Label cookieLabel = new Label("Cookie: ");
        cookieTextField = new TextField();
        cookieTextField.setPromptText("例: key=value; key2=value2");
        HBox.setHgrow(cookieTextField, javafx.scene.layout.Priority.ALWAYS);

        cookieBox.getChildren().addAll(cookieLabel, cookieTextField);
        advancedConfigContent.getChildren().add(cookieBox);

        // Content-Type 和请求体配置（同一行）
        HBox contentTypeAndBodyBox = new HBox();
        contentTypeAndBodyBox.setAlignment(Pos.CENTER);
        contentTypeAndBodyBox.setSpacing(10);

        Label contentTypeLabel = new Label("Content-Type: ");
        ObservableList<String> contentTypes = FXCollections.observableArrayList(
            "application/x-www-form-urlencoded",
            "application/json",
            "multipart/form-data",
            "text/plain",
            "application/xml"
        );
        contentTypeComboBox = new ComboBox<>(contentTypes);
        contentTypeComboBox.setValue("application/x-www-form-urlencoded");
        HBox.setHgrow(contentTypeComboBox, javafx.scene.layout.Priority.ALWAYS);

        Label requestBodyLabel = new Label("请求体: ");
        requestBodyTextField = new TextField();
        requestBodyTextField.setPromptText("POST 时生效 (例: {\"key\":\"value\"})");
        HBox.setHgrow(requestBodyTextField, javafx.scene.layout.Priority.ALWAYS);

        contentTypeAndBodyBox.getChildren().addAll(contentTypeLabel, contentTypeComboBox, requestBodyLabel, requestBodyTextField);
        advancedConfigContent.getChildren().add(contentTypeAndBodyBox);

        advancedConfigPane.setContent(advancedConfigContent);

        // =========================== TabPane：功能切换 ==========================
        TabPane functionTabPane = new TabPane();
        functionTabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);

        // 命令执行标签
        Tab cmdTab = new Tab("命令执行");
        cmdTab.setContent(getCommandExecutionPane());

        // 内存马注入标签
        Tab memshellTab = new Tab("内存马注入");
        memshellTab.setContent(getMemshellInjectionPane());

        functionTabPane.getTabs().addAll(cmdTab, memshellTab);

        // =========================== 日志区域 ==========================
        HBox logBox = new HBox();
        logBox.setAlignment(Pos.CENTER);
        logBox.setSpacing(10);

        logTextArea = new TextArea();
        logTextArea.setEditable(false);
        logBox.getChildren().add(logTextArea);
        HBox.setHgrow(logTextArea, javafx.scene.layout.Priority.ALWAYS);
        // 日志框自动填充剩余空间
        VBox.setVgrow(logBox, javafx.scene.layout.Priority.ALWAYS);

        // =========================== 清除日志按钮事件 ==========================
        clearLogButton.setOnAction(event -> {
            logTextArea.clear();
        });

        // =========================== 添加所有组件 ==========================
        exploitTab.getChildren().addAll(targetConfigBox, rememberMeConfigBox, exploitConfigBox, advancedConfigPane, functionTabPane, logBox);
        return exploitTab;
    }

    /**
     * 获取命令执行面板
     */
    private VBox getCommandExecutionPane() {
        VBox pane = new VBox();
        pane.setSpacing(10);
        pane.setPadding(new Insets(10));

        // 命令输入行
        HBox commandBox = new HBox();
        commandBox.setAlignment(Pos.CENTER);
        commandBox.setSpacing(10);

        Label commandLabel = new Label("命令: ");
        TextField commandTextField = new TextField();
        commandTextField.setPromptText("输入要执行的命令");
        HBox.setHgrow(commandTextField, javafx.scene.layout.Priority.ALWAYS);

        Button executeButton = new Button("执行");

        commandBox.getChildren().addAll(commandLabel, commandTextField, executeButton);

        // 事件处理
        executeButton.setOnAction(event -> {
            if (!validateConfig()) {
                return;
            }
            if (commandTextField.getText().trim().isEmpty()) {
                logTextArea.appendText("[EROR]请输入命令\n");
                return;
            }

            String command = commandTextField.getText().trim();
            logTextArea.appendText("[INFO]执行命令: " + command + "\n");

            executeButton.setDisable(true);
            commandTextField.clear();

            Task<String> task = new Task<String>() {
                @Override
                protected String call() {
                    try {
                        TargetOBJ targetOBJ = buildTargetOBJ();
                        return CommandExcute.commandExcuteWithResult(targetOBJ, command);
                    } catch (Exception e) {
                        final String errorMsg = e.getMessage();
                        return errorMsg != null && !errorMsg.isEmpty() ? "[EROR]" + errorMsg : "[EROR]命令执行失败，请检查配置";
                    }
                }

                @Override
                protected void succeeded() {
                    String result = getValue();
                    if (result != null && !result.isEmpty()) {
                        logTextArea.appendText("---------- 命令输出 ----------\n");
                        logTextArea.appendText(result + "\n");
                        logTextArea.appendText("-------------------------------\n\n");
                    } else {
                        logTextArea.appendText("[WARN]命令执行无返回\n");
                    }
                    executeButton.setDisable(false);
                }

                @Override
                protected void failed() {
                    executeButton.setDisable(false);
                }
            };
            new Thread(task).start();
        });

        pane.getChildren().addAll(commandBox);
        return pane;
    }

    /**
     * 获取内存马注入面板
     */
    private VBox getMemshellInjectionPane() {
        VBox pane = new VBox();
        pane.setSpacing(10);
        pane.setPadding(new Insets(10));

        // 内存马类型选择
        HBox typeBox = new HBox();
        typeBox.setAlignment(Pos.CENTER);
        typeBox.setSpacing(10);

        Label typeLabel = new Label("内存马类型: ");
        ObservableList<String> memTypes = FXCollections.observableArrayList(AllList.memTypes);
        ComboBox<String> memTypeComboBox = new ComboBox<>(memTypes);
        memTypeComboBox.setPromptText("选择内存马类型");

        // 新增：编辑内存马按钮（初始隐藏）
        Button editMemshellButton = new Button("编辑内存马");
        editMemshellButton.setVisible(false);  // 初始隐藏
        editMemshellButton.setManaged(false);  // 初始不占用布局空间

        typeBox.getChildren().addAll(typeLabel, memTypeComboBox, editMemshellButton);

        // 监听内存马类型选择变化，动态显示/隐藏编辑按钮
        memTypeComboBox.setOnAction(event -> {
            String selectedType = memTypeComboBox.getValue();
            if ("自定义内存马".equals(selectedType)) {
                editMemshellButton.setVisible(true);
                editMemshellButton.setManaged(true);
            } else {
                editMemshellButton.setVisible(false);
                editMemshellButton.setManaged(false);
                customMemshellBase64 = null;  // 清空自定义字节码
            }
        });

        // 编辑内存马按钮点击事件
        editMemshellButton.setOnAction(event -> {
            Dialog<String> dialog = new Dialog<>();
            dialog.setTitle("编辑内存马");
            dialog.setHeaderText("请输入内存马字节码的 Base64 编码");

            // 设置按钮
            ButtonType saveButtonType = new ButtonType("保存", ButtonBar.ButtonData.OK_DONE);
            dialog.getDialogPane().getButtonTypes().addAll(saveButtonType, ButtonType.CANCEL);

            // 创建 TextArea
            TextArea textArea = new TextArea();
            textArea.setPromptText("请输入内存马字节码的 Base64 编码");
            textArea.setPrefRowCount(10);
            textArea.setWrapText(true);

            VBox content = new VBox(10, new Label("Base64 编码:"), textArea);
            dialog.getDialogPane().setContent(content);

            // 转换结果
            dialog.setResultConverter(dialogButton -> {
                if (dialogButton == saveButtonType) {
                    return textArea.getText();
                }
                return null;
            });

            // 显示并处理
            dialog.showAndWait().ifPresent(base64Input -> {
                String trimmedInput = base64Input.trim();
                if (trimmedInput.isEmpty()) {
                    logTextArea.appendText("[EROR]Base64 编码不能为空\n");
                    return;
                }

                // 验证 Base64 编码有效性
                try {
                    byte[] decoded = Base64.getDecoder().decode(trimmedInput);
                    customMemshellBase64 = trimmedInput;
                    logTextArea.appendText("[SUCC]自定义内存马字节码已保存\n");
                    logTextArea.appendText("----------\n");
                    logTextArea.appendText("编码长度: " + trimmedInput.length() + " 字符\n");
                    logTextArea.appendText("解码大小: " + decoded.length + " 字节\n");
                    logTextArea.appendText("----------\n");
                } catch (IllegalArgumentException ex) {
                    logTextArea.appendText("[EROR]无效的 Base64 编码: " + ex.getMessage() + "\n");
                    customMemshellBase64 = null;
                }
            });
        });

        // 路径和密码配置
        HBox configBox = new HBox();
        configBox.setAlignment(Pos.CENTER);
        configBox.setSpacing(10);

        Label pathLabel = new Label("路径: ");
        TextField pathTextField = new TextField();
        pathTextField.setPromptText("/button.png（带斜杠）");
        pathTextField.setText("/button.png");
        pathTextField.setPrefWidth(200);

        Label passLabel = new Label("密码: ");
        TextField passTextField = new TextField();
        passTextField.setText("Test@1234");
        passTextField.setPromptText("设置密码");

        configBox.getChildren().addAll(pathLabel, pathTextField, passLabel, passTextField);

        // 注入按钮
        HBox buttonBox = new HBox();
        buttonBox.setAlignment(Pos.CENTER);
        buttonBox.setSpacing(10);

        Button injectButton = new Button("注入内存马");

        buttonBox.getChildren().addAll(injectButton);

        // 事件处理
        injectButton.setOnAction(event -> {
            if (!validateConfig()) {
                return;
            }
            if (memTypeComboBox.getValue() == null || memTypeComboBox.getValue().isEmpty()) {
                logTextArea.appendText("[EROR]请选择内存马类型\n");
                return;
            }
            if (pathTextField.getText().trim().isEmpty()) {
                logTextArea.appendText("[EROR]请输入内存马路径\n");
                return;
            }
            if (passTextField.getText().trim().isEmpty()) {
                logTextArea.appendText("[EROR]请输入内存马密码\n");
                return;
            }

            String memType = memTypeComboBox.getValue();
            String path = pathTextField.getText().trim();
            String password = passTextField.getText().trim();
            String gadget = gadgetComboBox.getValue();

            // 自定义内存马验证
            if ("自定义内存马".equals(memType)) {
                if (customMemshellBase64 == null || customMemshellBase64.isEmpty()) {
                    logTextArea.appendText("[EROR]请先点击「编辑内存马」按钮输入字节码\n");
                    return;
                }
            }

            logTextArea.appendText("[INFO]开始注入内存马: " + memType + "\n");
            injectButton.setDisable(true);

            Task<Void> task = new Task<Void>() {
                @Override
                protected Void call() {
                    try {
                        TargetOBJ targetOBJ = buildTargetOBJ();
                        MemshellService.InjectResult result;

                        // 根据内存马类型调用不同的注入方法
                        if ("自定义内存马".equals(memType)) {
                            result = MemshellService.injectMemshell(targetOBJ, customMemshellBase64, path, password, gadget, true);
                        } else {
                            result = MemshellService.injectMemshell(targetOBJ, memType, path, password, gadget);
                        }

                        javafx.application.Platform.runLater(() -> {
                            if (result.success) {
                                logTextArea.appendText("========== 注入成功 ==========\n");
                            } else {
                                logTextArea.appendText("========== 注入失败 ==========\n");
                            }
                            // 输出详细消息
                            logTextArea.appendText(result.message + "\n");

                            // 无论成功失败，都输出参数信息
                            logTextArea.appendText("类型: " + result.memshellType + "\n");
                            logTextArea.appendText("路径: " + result.path + "\n");
                            logTextArea.appendText("密码: " + result.password + "\n");
                            logTextArea.appendText("利用链: " + gadget + "\n");

                            // 统一输出认证 Header（无论是否为 null）
                            logTextArea.appendText("认证 Header: " + result.headerName + ": " + result.headerValue + "\n");

                            // 显示备注
                            if (result.remark != null && !result.remark.isEmpty()) {
                                logTextArea.appendText("备注: " + result.remark + "\n");
                            }

                            // 显示响应内容
                            logTextArea.appendText("----------\n");
                            logTextArea.appendText("响应内容:\n");
                            logTextArea.appendText(result.response + "\n");
                            logTextArea.appendText("==============================\n\n");
                        });
                    } catch (Exception e) {
                        final String errorMsg = e.getMessage();
                        final String debugInfo = e.getClass().getSimpleName();
                        javafx.application.Platform.runLater(() -> {
                            logTextArea.appendText("========== 注入异常 ==========\n");
                            logTextArea.appendText("错误信息: " + (errorMsg != null && !errorMsg.isEmpty() ? errorMsg : "内存马注入失败，请检查配置") + "\n");
                            logTextArea.appendText("异常类型: " + debugInfo + "\n");
                            logTextArea.appendText("==============================\n\n");
                        });
                    }
                    return null;
                }

                @Override
                protected void succeeded() {
                    injectButton.setDisable(false);
                }

                @Override
                protected void failed() {
                    injectButton.setDisable(false);
                }
            };
            new Thread(task).start();
        });

        pane.getChildren().addAll(typeBox, configBox, buttonBox);
        return pane;
    }

    /**
     * 验证基础配置
     */
    private boolean validateConfig() {
        if (targetUrlTextField.getText().trim().isEmpty()) {
            logTextArea.appendText("[EROR]请输入目标地址\n");
            return false;
        }
        if (keyTextField.getText().trim().isEmpty()) {
            logTextArea.appendText("[EROR]请输入 Key\n");
            return false;
        }
        if (gadgetComboBox.getValue() == null || gadgetComboBox.getValue().isEmpty()) {
            logTextArea.appendText("[EROR]请选择利用链\n");
            return false;
        }
        return true;
    }

    /**
     * 构建目标对象
     */
    private TargetOBJ buildTargetOBJ() {
        TargetOBJ targetOBJ = new TargetOBJ(targetUrlTextField.getText().trim());
        targetOBJ.setKey(keyTextField.getText().trim());
        targetOBJ.setGadget(gadgetComboBox.getValue());
        targetOBJ.setEcho(echoComboBox.getValue());
        targetOBJ.setRememberMeFlag(keywordTextField.getText().trim());
        targetOBJ.setRequestType(requestTypeComboBox.getValue());

        // 优先使用用户选择的加密方式，如果为空则从配置读取
        String selectedCryptType = cryptTypeComboBox.getValue();
        if (selectedCryptType != null && !selectedCryptType.isEmpty()) {
            targetOBJ.setCryptType(selectedCryptType);
        } else {
            ExploitConfig config = ExploitConfig.getInstance();
            if (config.getCryptType() != null && !config.getCryptType().isEmpty()) {
                targetOBJ.setCryptType(config.getCryptType());
            }
        }

        // 应用高级配置
        Map<String, String> headers = new HashMap<>();

        // 应用 Cookie
        if (cookieTextField != null && !cookieTextField.getText().trim().isEmpty()) {
            headers.put("Cookie", cookieTextField.getText().trim());
        }

        // 应用 Content-Type
        if (contentTypeComboBox != null && contentTypeComboBox.getValue() != null) {
            headers.put("Content-Type", contentTypeComboBox.getValue());
        }

        if (!headers.isEmpty()) {
            targetOBJ.setHeaders(headers);
        }

        return targetOBJ;
    }

    /**
     * 从全局配置加载数据（公共方法）
     */
    public void updateFromConfig() {
        ExploitConfig config = ExploitConfig.getInstance();

        if (!config.isComplete()) {
            return;
        }

        // 加载配置到UI
        targetUrlTextField.setText(config.getTargetUrl());
        keyTextField.setText(config.getKey());
        gadgetComboBox.setValue(config.getGadget());
        echoComboBox.setValue(config.getEcho());

        // 同步请求方式
        if (config.getRequestType() != null && !config.getRequestType().isEmpty()) {
            requestTypeComboBox.setValue(config.getRequestType());
        }

        // 同步加密方式
        if (config.getCryptType() != null && !config.getCryptType().isEmpty()) {
            cryptTypeComboBox.setValue(config.getCryptType());
        }

        // 同步 Keyword
        if (config.getRememberMeFlag() != null && !config.getRememberMeFlag().isEmpty()) {
            keywordTextField.setText(config.getRememberMeFlag());
        }

        // 同步 Cookie
        if (config.getCookie() != null && !config.getCookie().isEmpty()) {
            cookieTextField.setText(config.getCookie());
        }

        // 同步 Content-Type
        if (config.getContentType() != null && !config.getContentType().isEmpty()) {
            contentTypeComboBox.setValue(config.getContentType());
        }

        // 同步请求体
        if (config.getRequestBody() != null && !config.getRequestBody().isEmpty()) {
            requestBodyTextField.setText(config.getRequestBody());
        }
    }

    /**
     * 静态方法：更新当前实例的配置
     */
    public static void updateFromConfigStatic() {
        if (instance != null) {
            javafx.application.Platform.runLater(() -> {
                instance.updateFromConfig();
            });
        }
    }
}
