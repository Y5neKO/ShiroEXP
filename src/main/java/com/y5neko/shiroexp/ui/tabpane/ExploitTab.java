package com.y5neko.shiroexp.ui.tabpane;

import com.y5neko.shiroexp.config.AllList;
import com.y5neko.shiroexp.config.ExploitConfig;
import com.y5neko.shiroexp.object.TargetOBJ;
import com.y5neko.shiroexp.payloads.CommandExcute;
import com.y5neko.shiroexp.payloads.MemshellService;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;

import java.net.URL;
import java.util.HashMap;
import java.util.Map;

/**
 * 漏洞利用标签页
 * 包含命令执行和内存马注入功能
 */
public class ExploitTab {
    // 静态引用，用于外部更新UI
    private static ExploitTab instance;

    private TextField targetUrlTextField;
    private TextField keyTextField;
    private ComboBox<String> gadgetComboBox;
    private ComboBox<String> echoComboBox;
    private TextArea logTextArea;
    private TextField cookieTextField;

    public VBox getExploitTab() {
        // 注册实例
        instance = this;
        VBox exploitTab = new VBox();
        exploitTab.setSpacing(10);
        exploitTab.setPadding(new Insets(10));
        exploitTab.getStylesheets().add("css/TextField.css");

        // =========================== 第一行：目标配置 ==========================
        HBox targetConfigBox = new HBox();
        targetConfigBox.setAlignment(Pos.CENTER);
        targetConfigBox.setSpacing(10);

        Label targetUrlLabel = new Label("目标地址: ");
        targetUrlTextField = new TextField();
        targetUrlTextField.setPromptText("http://example.com");
        HBox.setHgrow(targetUrlTextField, javafx.scene.layout.Priority.ALWAYS);

        Label keyLabel = new Label("Key: ");
        keyTextField = new TextField();
        keyTextField.setPromptText("Shiro Key");
        keyTextField.setPrefWidth(200);

        Button clearLogButton = new Button("清除日志");

        targetConfigBox.getChildren().addAll(targetUrlLabel, targetUrlTextField, keyLabel, keyTextField, clearLogButton);

        // =========================== 第二行：利用链配置 ==========================
        HBox exploitConfigBox = new HBox();
        exploitConfigBox.setAlignment(Pos.CENTER);
        exploitConfigBox.setSpacing(10);

        Label gadgetLabel = new Label("利用链: ");
        ObservableList<String> gadgets = FXCollections.observableArrayList(AllList.gadgets);
        gadgetComboBox = new ComboBox<>(gadgets);
        if (!gadgets.isEmpty()) {
            gadgetComboBox.setValue(gadgets.get(0));
        }

        Label echoLabel = new Label("回显方式: ");
        ObservableList<String> echoes = FXCollections.observableArrayList(AllList.echoGadgets);
        echoComboBox = new ComboBox<>(echoes);
        if (!echoes.isEmpty()) {
            echoComboBox.setValue(echoes.get(0));
        }

        exploitConfigBox.getChildren().addAll(gadgetLabel, gadgetComboBox, echoLabel, echoComboBox);

        // =========================== 第三行：Cookie 配置 ==========================
        HBox cookieBox = new HBox();
        cookieBox.setAlignment(Pos.CENTER);
        cookieBox.setSpacing(10);

        Label cookieLabel = new Label("Cookie: ");
        cookieTextField = new TextField();
        cookieTextField.setPromptText("例: key=value; key2=value2");
        HBox.setHgrow(cookieTextField, javafx.scene.layout.Priority.ALWAYS);

        cookieBox.getChildren().addAll(cookieLabel, cookieTextField);

        // =========================== TabPane：功能切换 ==========================
        TabPane functionTabPane = new TabPane();
        functionTabPane.setTabClosingPolicy(TabPane.TabClosingPolicy.UNAVAILABLE);

        // 命令执行标签
        Tab cmdTab = new Tab("命令执行");
        cmdTab.setContent(getCommandExecutionPane());

        // 内存马注入标签
        Tab memshellTab = new Tab("内存马注入");
        memshellTab.setContent(getMemshellInjectionPane());

        functionTabPane.getTabs().addAll(cmdTab, memshellTab);

        // =========================== 日志区域 ==========================
        HBox logBox = new HBox();
        logBox.setAlignment(Pos.CENTER);
        logBox.setSpacing(10);

        logTextArea = new TextArea();
        logTextArea.setEditable(false);
        logBox.getChildren().add(logTextArea);
        HBox.setHgrow(logTextArea, javafx.scene.layout.Priority.ALWAYS);
        // 日志框自动填充剩余空间
        VBox.setVgrow(logBox, javafx.scene.layout.Priority.ALWAYS);

        // =========================== 清除日志按钮事件 ==========================
        clearLogButton.setOnAction(event -> {
            logTextArea.clear();
        });

        // =========================== 添加所有组件 ==========================
        exploitTab.getChildren().addAll(targetConfigBox, exploitConfigBox, cookieBox, functionTabPane, logBox);
        return exploitTab;
    }

    /**
     * 获取命令执行面板
     */
    private VBox getCommandExecutionPane() {
        VBox pane = new VBox();
        pane.setSpacing(10);
        pane.setPadding(new Insets(10));

        // 命令输入行
        HBox commandBox = new HBox();
        commandBox.setAlignment(Pos.CENTER);
        commandBox.setSpacing(10);

        Label commandLabel = new Label("命令: ");
        TextField commandTextField = new TextField();
        commandTextField.setPromptText("输入要执行的命令");
        HBox.setHgrow(commandTextField, javafx.scene.layout.Priority.ALWAYS);

        Button executeButton = new Button("执行");

        commandBox.getChildren().addAll(commandLabel, commandTextField, executeButton);

        // 事件处理
        executeButton.setOnAction(event -> {
            if (!validateConfig()) {
                return;
            }
            if (commandTextField.getText().trim().isEmpty()) {
                logTextArea.appendText("[EROR]请输入命令\n");
                return;
            }

            String command = commandTextField.getText().trim();
            logTextArea.appendText("[INFO]执行命令: " + command + "\n");

            executeButton.setDisable(true);
            commandTextField.clear();

            Task<String> task = new Task<String>() {
                @Override
                protected String call() {
                    try {
                        TargetOBJ targetOBJ = buildTargetOBJ();
                        return CommandExcute.commandExcuteWithResult(targetOBJ, command);
                    } catch (Exception e) {
                        final String errorMsg = e.getMessage();
                        return errorMsg != null && !errorMsg.isEmpty() ? "[EROR]" + errorMsg : "[EROR]命令执行失败，请检查配置";
                    }
                }

                @Override
                protected void succeeded() {
                    String result = getValue();
                    if (result != null && !result.isEmpty()) {
                        logTextArea.appendText("---------- 命令输出 ----------\n");
                        logTextArea.appendText(result + "\n");
                        logTextArea.appendText("-------------------------------\n\n");
                    } else {
                        logTextArea.appendText("[WARN]命令执行无返回\n");
                    }
                    executeButton.setDisable(false);
                }

                @Override
                protected void failed() {
                    executeButton.setDisable(false);
                }
            };
            new Thread(task).start();
        });

        pane.getChildren().addAll(commandBox);
        return pane;
    }

    /**
     * 获取内存马注入面板
     */
    private VBox getMemshellInjectionPane() {
        VBox pane = new VBox();
        pane.setSpacing(10);
        pane.setPadding(new Insets(10));

        // 内存马类型选择
        HBox typeBox = new HBox();
        typeBox.setAlignment(Pos.CENTER);
        typeBox.setSpacing(10);

        Label typeLabel = new Label("内存马类型: ");
        ObservableList<String> memTypes = FXCollections.observableArrayList(AllList.memTypes);
        ComboBox<String> memTypeComboBox = new ComboBox<>(memTypes);
        memTypeComboBox.setPromptText("选择内存马类型");

        typeBox.getChildren().addAll(typeLabel, memTypeComboBox);

        // 路径和密码配置
        HBox configBox = new HBox();
        configBox.setAlignment(Pos.CENTER);
        configBox.setSpacing(10);

        Label pathLabel = new Label("路径: ");
        TextField pathTextField = new TextField();
        pathTextField.setPromptText("/shell.png");
        pathTextField.setPrefWidth(200);

        Label passLabel = new Label("密码: ");
        TextField passTextField = new TextField();
        passTextField.setPromptText("设置密码");

        configBox.getChildren().addAll(pathLabel, pathTextField, passLabel, passTextField);

        // 注入按钮
        HBox buttonBox = new HBox();
        buttonBox.setAlignment(Pos.CENTER);
        buttonBox.setSpacing(10);

        Button injectButton = new Button("注入内存马");

        buttonBox.getChildren().addAll(injectButton);

        // 事件处理
        injectButton.setOnAction(event -> {
            if (!validateConfig()) {
                return;
            }
            if (memTypeComboBox.getValue() == null || memTypeComboBox.getValue().isEmpty()) {
                logTextArea.appendText("[EROR]请选择内存马类型\n");
                return;
            }
            if (pathTextField.getText().trim().isEmpty()) {
                logTextArea.appendText("[EROR]请输入内存马路径\n");
                return;
            }
            if (passTextField.getText().trim().isEmpty()) {
                logTextArea.appendText("[EROR]请输入内存马密码\n");
                return;
            }

            String memType = memTypeComboBox.getValue();
            String path = pathTextField.getText().trim();
            String password = passTextField.getText().trim();
            String gadget = gadgetComboBox.getValue();

            logTextArea.appendText("[INFO]开始注入内存马: " + memType + "\n");
            injectButton.setDisable(true);

            Task<Void> task = new Task<Void>() {
                @Override
                protected Void call() {
                    try {
                        TargetOBJ targetOBJ = buildTargetOBJ();
                        MemshellService.InjectResult result = MemshellService.injectMemshell(targetOBJ, memType, path, password, gadget);

                        javafx.application.Platform.runLater(() -> {
                            if (result.success) {
                                logTextArea.appendText("========== 注入成功 ==========\n");
                                logTextArea.appendText("类型: " + result.memshellType + "\n");
                                logTextArea.appendText("地址: " + result.path + "\n");
                                logTextArea.appendText("密码: " + result.password + "\n");
                                logTextArea.appendText("利用链: " + gadget + "\n");
                                logTextArea.appendText("==============================\n\n");
                            } else {
                                logTextArea.appendText("========== 注入失败 ==========\n");
                                logTextArea.appendText("错误信息: " + result.message + "\n");
                                logTextArea.appendText("内存马类型: " + result.memshellType + "\n");
                                logTextArea.appendText("利用链: " + gadget + "\n");
                                logTextArea.appendText("----------\n");
                                logTextArea.appendText("响应内容:\n");
                                logTextArea.appendText(result.response + "\n");
                                logTextArea.appendText("==============================\n\n");
                            }
                        });
                    } catch (Exception e) {
                        final String errorMsg = e.getMessage();
                        final String debugInfo = e.getClass().getSimpleName();
                        javafx.application.Platform.runLater(() -> {
                            logTextArea.appendText("========== 注入异常 ==========\n");
                            logTextArea.appendText("错误信息: " + (errorMsg != null && !errorMsg.isEmpty() ? errorMsg : "内存马注入失败，请检查配置") + "\n");
                            logTextArea.appendText("异常类型: " + debugInfo + "\n");
                            logTextArea.appendText("==============================\n\n");
                        });
                    }
                    return null;
                }

                @Override
                protected void succeeded() {
                    injectButton.setDisable(false);
                }

                @Override
                protected void failed() {
                    injectButton.setDisable(false);
                }
            };
            new Thread(task).start();
        });

        pane.getChildren().addAll(typeBox, configBox, buttonBox);
        return pane;
    }

    /**
     * 验证基础配置
     */
    private boolean validateConfig() {
        if (targetUrlTextField.getText().trim().isEmpty()) {
            logTextArea.appendText("[EROR]请输入目标地址\n");
            return false;
        }
        if (keyTextField.getText().trim().isEmpty()) {
            logTextArea.appendText("[EROR]请输入 Key\n");
            return false;
        }
        if (gadgetComboBox.getValue() == null || gadgetComboBox.getValue().isEmpty()) {
            logTextArea.appendText("[EROR]请选择利用链\n");
            return false;
        }
        return true;
    }

    /**
     * 构建目标对象
     */
    private TargetOBJ buildTargetOBJ() {
        TargetOBJ targetOBJ = new TargetOBJ(targetUrlTextField.getText().trim());
        targetOBJ.setKey(keyTextField.getText().trim());
        targetOBJ.setGadget(gadgetComboBox.getValue());
        targetOBJ.setEcho(echoComboBox.getValue());
        targetOBJ.setRememberMeFlag("rememberMe");

        // 应用高级配置
        if (cookieTextField != null && !cookieTextField.getText().trim().isEmpty()) {
            Map<String, String> headers = new HashMap<>();
            headers.put("Cookie", cookieTextField.getText().trim());
            targetOBJ.setHeaders(headers);
        }

        return targetOBJ;
    }

    /**
     * 从全局配置加载数据（公共方法）
     */
    public void updateFromConfig() {
        ExploitConfig config = ExploitConfig.getInstance();

        if (!config.isComplete()) {
            if (logTextArea != null) {
                logTextArea.appendText("[WARN]未找到有效的爆破配置\n");
                logTextArea.appendText("[INFO]请先在「Shiro550」标签页完成 Key 爆破和回显链检测\n");
            }
            return;
        }

        // 加载配置到UI
        targetUrlTextField.setText(config.getTargetUrl());
        keyTextField.setText(config.getKey());
        gadgetComboBox.setValue(config.getGadget());
        echoComboBox.setValue(config.getEcho());

        if (config.getCookie() != null && !config.getCookie().isEmpty()) {
            cookieTextField.setText(config.getCookie());
        }

        if (logTextArea != null) {
            logTextArea.appendText("[SUCC]配置已自动同步！\n");
            logTextArea.appendText("----------------------------------------\n");
            logTextArea.appendText("目标地址: " + config.getTargetUrl() + "\n");
            logTextArea.appendText("Key: " + config.getKey() + "\n");
            logTextArea.appendText("利用链: " + config.getGadget() + "\n");
            logTextArea.appendText("回显方式: " + config.getEcho() + "\n");
            logTextArea.appendText("加密方式: " + config.getCryptType() + "\n");
            logTextArea.appendText("----------------------------------------\n");
            logTextArea.appendText("[提示] 现在可以进行命令执行或内存马注入\n");
        }
    }

    /**
     * 静态方法：更新当前实例的配置
     */
    public static void updateFromConfigStatic() {
        if (instance != null) {
            javafx.application.Platform.runLater(() -> {
                instance.updateFromConfig();
            });
        }
    }
}
